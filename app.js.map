{"version":3,"sources":["webpack:///webpack/bootstrap b15d55500273de71ac21","webpack:///./node_modules/rxjs-es/Observable.js","webpack:///./node_modules/rxjs-es/util/root.js","webpack:///./node_modules/hyperhtml-element/index.js","webpack:///./node_modules/rxjs-es/util/isFunction.js","webpack:///./node_modules/rxjs-es/util/errorObject.js","webpack:///./node_modules/rxjs-es/Subscriber.js","webpack:///./node_modules/rxjs-es/Subscription.js","webpack:///./node_modules/rxjs-es/util/tryCatch.js","webpack:///./node_modules/rxjs-es/symbol/rxSubscriber.js","webpack:///./node_modules/rxjs-es/add/operator/map.js","webpack:///./src/components/x-app.js","webpack:///./node_modules/hyperhtml/hyperhtml.js","webpack:///./src/components/x-button.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/rxjs-es/util/toSubscriber.js","webpack:///./node_modules/rxjs-es/util/isArray.js","webpack:///./node_modules/rxjs-es/util/isObject.js","webpack:///./node_modules/rxjs-es/util/UnsubscriptionError.js","webpack:///./node_modules/rxjs-es/Observer.js","webpack:///./node_modules/rxjs-es/symbol/observable.js","webpack:///./node_modules/rxjs-es/add/observable/fromEvent.js","webpack:///./node_modules/rxjs-es/observable/fromEvent.js","webpack:///./node_modules/rxjs-es/observable/FromEventObservable.js","webpack:///./node_modules/rxjs-es/operator/map.js","webpack:///./src/components/x-fakedata.js","webpack:///./node_modules/rxjs-es/add/observable/fromPromise.js","webpack:///./node_modules/rxjs-es/observable/fromPromise.js","webpack:///./node_modules/rxjs-es/observable/PromiseObservable.js"],"names":["__webpack_require__","moduleId","installedModules","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Observable","[object Object]","subscribe","this","_isScalar","_subscribe","operator","observable","source","observerOrNext","error","complete","sink","__WEBPACK_IMPORTED_MODULE_1__util_toSubscriber__","add","syncErrorThrowable","syncErrorThrown","syncErrorValue","next","PromiseCtor","__WEBPACK_IMPORTED_MODULE_0__util_root__","Rx","config","Promise","Error","resolve","reject","subscription","value","err","unsubscribe","subscriber","__WEBPACK_IMPORTED_MODULE_2__symbol_observable__","__webpack_exports__","create","root","objectTypes","boolean","function","number","string","undefined","self","window","freeGlobal","global","HyperHTMLElement","__init","HTMLElement","Class","proto","observedAttributes","forEach","replace","$0","$1","toUpperCase","getAttribute","setAttribute","onChanged","attributeChangedCallback","hasChange","created","writable","prev","curr","apply","arguments","onConnected","connectedCallback","hasConnect","event","type","customElements","define","html","__hyperHTML","hyperHTML","bind","shadowRoot","_shadowRoot","o_O","x","errorObject","e","Subscriber","__WEBPACK_IMPORTED_MODULE_1__Subscription__","destinationOrNext","super","isStopped","length","destination","__WEBPACK_IMPORTED_MODULE_2__Observer__","SafeSubscriber","__WEBPACK_IMPORTED_MODULE_3__symbol_rxSubscriber__","_next","_error","_complete","closed","_parent","context","__WEBPACK_IMPORTED_MODULE_0__util_isFunction__","_context","__tryOrSetError","__tryOrUnsub","fn","parent","Subscription","_unsubscribe","errors","hasErrors","_subscriptions","__WEBPACK_IMPORTED_MODULE_2__util_isFunction__","__WEBPACK_IMPORTED_MODULE_3__util_tryCatch__","__WEBPACK_IMPORTED_MODULE_4__util_errorObject__","push","__WEBPACK_IMPORTED_MODULE_0__util_isArray__","index","len","sub","__WEBPACK_IMPORTED_MODULE_1__util_isObject__","__WEBPACK_IMPORTED_MODULE_5__util_UnsubscriptionError__","concat","teardown","EMPTY","subscriptions","subscriptionIndex","indexOf","splice","empty","tryCatcher","tryCatchTarget","__WEBPACK_IMPORTED_MODULE_0__errorObject__","Symbol","$$rxSubscriber","for","__WEBPACK_IMPORTED_MODULE_0__Observable__","map","__WEBPACK_IMPORTED_MODULE_1__operator_map__","XApp","__WEBPACK_IMPORTED_MODULE_0_hyperhtml_element___default","a","Math","random","render","globalDocument","template","hyper","hypers","FF","unique","upgrade","set","update","updates","indexOfDifferences","b","aLength","bLength","populateNode","child","nodeType","ELEMENT_NODE","childNodes","removeNodeList","resetAndPopulate","DOCUMENT_FRAGMENT_NODE","TEXT_NODE","textContent","list","startIndex","parentNode","removeChild","appendChild","updateViaArray","node","fragment","emptyFragment","appendNodes","slice","setAnyContent","any","innerHTML","children","isArray","join","isPromise_ish","all","then","attribute","removeAttributes","oldValue","ownerElement","isEvent","test","isSpecial","OWNER_SVG_ELEMENT","SHOULD_USE_ATTRIBUTE","newValue","removeEventListener","addEventListener","setTextContent","setVirtualContent","anyVirtual","createFragment","insertBefore","updateVirtualNodes","attributesSeeker","paths","IE","UID","UIDC","attributes","Path","IEAttributes","shift","commentsSeeker","text","COMMENT_NODE","createText","replaceChild","nodeName","fnEscape","oEscape","createContent","content","trim","createDocumentFragment","document","createSVGFragment","createHTMLFragment","ownerDocument","container","createElement","hasContent","needsTableWrap","selector","RegExp","querySelectorAll","createElementNS","SVG_NAMESPACE","createTextNode","discoverNode","virtual","info","target","path","virtualNode","getNode","hasAttribute","before","getTextContent","after","firstChild","getChildren","virtualChildren","previousElementSibling","nextElementSibling","createComment","removePreviousText","direction","method","unshift","removeAttributeList","removeAttribute","previousSibling","setContent","createPath","createTemplate","no","comments","templates","ATTRIBUTE_NODE","createUpdates","discoverUpdates","notAdopting","cloneNode","wireContent","setup","adopter","statics","args","adopt","wireWeakly","obj","wire","wires","id","escape","reEscape","templateObjects","EXPANDO","Date","featureFragment","navigator","userAgent","parseFloat","WK","&","<",">","'","\"","$WeakMap","WeakMap","$Map","Map","k","v","Array","toString","key","append","j","$2","nextSibling","clone","XButton","attachShadow","mode","__WEBPACK_IMPORTED_MODULE_1_rxjs_es_Observable__","fromEvent","evt","console","log","clientX","y","clientY","data","JSON","stringify","g","Function","eval","nextOrObserver","__WEBPACK_IMPORTED_MODULE_0__Subscriber__","__WEBPACK_IMPORTED_MODULE_1__symbol_rxSubscriber__","UnsubscriptionError","stack","message","$$observable","getSymbolObservable","__WEBPACK_IMPORTED_MODULE_1__observable_fromEvent__","isNodeStyleEventEmmitter","sourceObj","addListener","removeListener","isJQueryStyleEventEmitter","on","off","isNodeList","isHTMLCollection","isEventTarget","FromEventObservable","eventName","options","handler","setupSubscription","__WEBPACK_IMPORTED_MODULE_4__Subscription__","result","__WEBPACK_IMPORTED_MODULE_1__util_tryCatch__","__WEBPACK_IMPORTED_MODULE_3__util_errorObject__","project","thisArg","TypeError","lift","MapOperator","MapSubscriber","count","FakeData","endpoint","items","parse","username","printItems","getData","fetch","r","json","fromPromise","__WEBPACK_IMPORTED_MODULE_1__observable_fromPromise__","dispatchNext","arg","dispatchError","PromiseObservable","__WEBPACK_IMPORTED_MODULE_1__Observable__","promise","scheduler","setTimeout","schedule"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b15d55500273de71ac21","import { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { $$observable } from './symbol/observable';\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    constructor(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    lift(operator) {\n        const observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    subscribe(observerOrNext, error, complete) {\n        const { operator } = this;\n        const sink = toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this);\n        }\n        else {\n            sink.add(this._subscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    }\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    forEach(next, PromiseCtor) {\n        if (!PromiseCtor) {\n            if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n                PromiseCtor = root.Rx.config.Promise;\n            }\n            else if (root.Promise) {\n                PromiseCtor = root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor((resolve, reject) => {\n            const subscription = this.subscribe((value) => {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    }\n    _subscribe(subscriber) {\n        return this.source.subscribe(subscriber);\n    }\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    [$$observable]() {\n        return this;\n    }\n}\n// HACK: Since TypeScript inherits static properties too, we have to\n// fight against TypeScript here so Subject can have a different static create signature\n/**\n * Creates a new cold Observable by calling the Observable constructor\n * @static true\n * @owner Observable\n * @method create\n * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n * @return {Observable} a new cold observable\n */\nObservable.create = (subscribe) => {\n    return new Observable(subscribe);\n};\n//# sourceMappingURL=Observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/Observable.js\n// module id = 0\n// module chunks = 0","let objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexport let root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\nlet freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/root.js\n// module id = 1\n// module chunks = 0","const HyperHTMLElement = (defineProperty => {\n  /*! (C) 2017 Andrea Giammarchi - ISC Style License */\n  const __init = {value: false};\n  return class HyperHTMLElement extends HTMLElement {\n\n    // define a custom-element in the CustomElementsRegistry\n    // class MyEl extends HyperHTMLElement {}\n    // MyEl.define('my-el');\n    static define(name) {\n      const Class = this;\n      const proto = Class.prototype;\n\n      // if observedAttributes contains attributes to observe\n      // HyperHTMLElement will directly reflect get/setAttribute\n      // operation once these attributes are used, example:\n      // el.observed = 123;\n      // will automatically do\n      // el.setAttribute('observed', 123);\n      // triggering also the attributeChangedCallback\n      (Class.observedAttributes || []).forEach(name => {\n        if (!(name in proto)) defineProperty(\n          proto,\n          name.replace(/-([a-z])/g, ($0, $1) => $1.toUpperCase()),\n          {\n            configurable: true,\n            get() { return this.getAttribute(name); },\n            set(value) { this.setAttribute(name, value); }\n          }\n        );\n      });\n\n      const onChanged = proto.attributeChangedCallback;\n      const hasChange = !!onChanged;\n\n      // created() {} is the entry point to do whatever you want.\n      // Once the node is live and upgraded as Custom Element.\n      // This method grants to be triggered at the right time,\n      // which is always once, and right before either\n      // attributeChangedCallback or connectedCallback\n      const created = proto.created;\n      if (created) {\n        // used to ensure create() is called once and once only\n        defineProperty(\n          proto,\n          '__init',\n          {\n            configurable: true,\n            writable: true,\n            value: true\n          }\n        );\n\n        // ⚠️ if you need to overwrite/change attributeChangedCallback method\n        //    at runtime after class definition, be sure you do so\n        //    via Object.defineProperty to preserve its non-enumerable nature.\n        defineProperty(\n          proto,\n          'attributeChangedCallback',\n          {\n            configurable: true,\n            value(name, prev, curr) {\n              if (this.__init) {\n                created.call(defineProperty(this, '__init', __init));\n              }\n              // ensure setting same value twice\n              // won't trigger twice attributeChangedCallback\n              if (hasChange && prev !== curr) {\n                onChanged.apply(this, arguments);\n              }\n            }\n          }\n        );\n\n        // ⚠️ if you need to overwrite/change connectedCallback method\n        //    at runtime after class definition, be sure you do so\n        //    via Object.defineProperty to preserve its non-enumerable nature.\n        const onConnected = proto.connectedCallback;\n        const hasConnect = !!onConnected;\n        defineProperty(\n          proto,\n          'connectedCallback',\n          {\n            configurable: true,\n            value() {\n              if (this.__init) {\n                created.call(defineProperty(this, '__init', __init));\n              }\n              if (hasConnect) {\n                onConnected.apply(this, arguments);\n              }\n            }\n          }\n        );\n      } else if (hasChange) {\n        // ⚠️ if you need to overwrite/change attributeChangedCallback method\n        //    at runtime after class definition, be sure you do so\n        //    via Object.defineProperty to preserve its non-enumerable nature.\n        defineProperty(\n          proto,\n          'attributeChangedCallback',\n          {\n            configurable: true,\n            value(name, prev, curr) {\n              // ensure setting same value twice\n              // won't trigger twice attributeChangedCallback\n              if (prev !== curr) {\n                onChanged.apply(this, arguments);\n              }\n            }\n          }\n        );\n      }\n\n      // whenever you want to directly use the component itself\n      // as EventListener, you can pass it directly.\n      // https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n      //  class Reactive extends HyperHTMLElement {\n      //    oninput(e) { console.log(this, 'changed', e.target.value); }\n      //    render() { this.html`<input oninput=\"${this}\">`; }\n      //  }\n      if (!('handleEvent' in proto)) {\n        // ⚠️ if you need to overwrite/change handleEvent method\n        //    at runtime after class definition, be sure you do so\n        //    via Object.defineProperty to preserve its non-enumerable nature.\n        defineProperty(\n          proto,\n          'handleEvent',\n          {\n            configurable: true,\n            value(event) {\n              this['on' + event.type](event);\n            }\n          }\n        );\n      }\n      customElements.define(name, Class);\n      return Class;\n    }\n\n    // lazily bind once hyperHTML logic\n    // to either the shadowRoot, if present and open,\n    // the _shadowRoot property, if set due closed shadow root,\n    // or the custom-element itself if no Shadow DOM is used.\n    get html() {\n      // ⚠️ defineProperty(this, 'html', {...}) would be the intent\n      //    then you have to deal with IE11 and broken ES5 implementations\n      //    where a getter in the prototype curses forever instances\n      //    properties definition.\n      return this.__hyperHTML || defineProperty(this, '__hyperHTML', {\n        configurable: true,\n        value: hyperHTML.bind(\n          // in case of Shadow DOM {mode: \"open\"}, use it\n          this.shadowRoot ||\n          // in case of Shadow DOM {mode: \"close\"}, use it\n          // this needs the following reference created upfront\n          // this._shadowRoot = this.attachShadow({mode: \"close\"});\n          this._shadowRoot ||\n          // if no Shadow DOM is used, simply use the component\n          // as container for its own content (it just works too)\n          this\n        )\n      }).__hyperHTML;\n    }\n\n  };\n\n})(Object.defineProperty);\n\ntry {\n  // try to export HyperHTMLElement as module\n  module.exports = HyperHTMLElement;\n  // if possible, also eventually require hyperHTML\n  // and hoist it on the current scope\n  var hyperHTML = hyperHTML || require('hyperhtml');\n} catch(o_O) {}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/hyperhtml-element/index.js\n// module id = 2\n// module chunks = 0","export function isFunction(x) {\n    return typeof x === 'function';\n}\n//# sourceMappingURL=isFunction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/isFunction.js\n// module id = 3\n// module chunks = 0","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport var errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/errorObject.js\n// module id = 4\n// module chunks = 0","import { isFunction } from './util/isFunction';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { $$rxSubscriber } from './symbol/rxSubscriber';\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber extends Subscription {\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    constructor(destinationOrNext, error, complete) {\n        super();\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = emptyObserver;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = emptyObserver;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    [$$rxSubscriber]() { return this; }\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    static create(next, error, complete) {\n        const subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    }\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    next(value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    }\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    error(err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    }\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    complete() {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    }\n    unsubscribe() {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        super.unsubscribe();\n    }\n    _next(value) {\n        this.destination.next(value);\n    }\n    _error(err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    }\n    _complete() {\n        this.destination.complete();\n        this.unsubscribe();\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber extends Subscriber {\n    constructor(_parent, observerOrNext, error, complete) {\n        super();\n        this._parent = _parent;\n        let next;\n        let context = this;\n        if (isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    next(value) {\n        if (!this.isStopped && this._next) {\n            const { _parent } = this;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    }\n    error(err) {\n        if (!this.isStopped) {\n            const { _parent } = this;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    }\n    complete() {\n        if (!this.isStopped) {\n            const { _parent } = this;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    }\n    __tryOrUnsub(fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    }\n    __tryOrSetError(parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    }\n    _unsubscribe() {\n        const { _parent } = this;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/Subscriber.js\n// module id = 5\n// module chunks = 0","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    constructor(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    unsubscribe() {\n        let hasErrors = false;\n        let errors;\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        const { _unsubscribe, _subscriptions } = this;\n        this._subscriptions = null;\n        if (isFunction(_unsubscribe)) {\n            let trial = tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject.e);\n            }\n        }\n        if (isArray(_subscriptions)) {\n            let index = -1;\n            const len = _subscriptions.length;\n            while (++index < len) {\n                const sub = _subscriptions[index];\n                if (isObject(sub)) {\n                    let trial = tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        let err = errorObject.e;\n                        if (err instanceof UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError(errors);\n        }\n    }\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    add(teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        let sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.closed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.closed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    }\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    remove(subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        const subscriptions = this._subscriptions;\n        if (subscriptions) {\n            const subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    }\n}\nSubscription.EMPTY = (function (empty) {\n    empty.closed = true;\n    return empty;\n}(new Subscription()));\n//# sourceMappingURL=Subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/Subscription.js\n// module id = 6\n// module chunks = 0","import { errorObject } from './errorObject';\nlet tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject.e = e;\n        return errorObject;\n    }\n}\nexport function tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n;\n//# sourceMappingURL=tryCatch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/tryCatch.js\n// module id = 7\n// module chunks = 0","import { root } from '../util/root';\nconst Symbol = root.Symbol;\nexport const $$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/symbol/rxSubscriber.js\n// module id = 8\n// module chunks = 0","import { Observable } from '../../Observable';\nimport { map } from '../../operator/map';\nObservable.prototype.map = map;\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/add/operator/map.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nimport HyperHTMLElement from 'hyperhtml-element';\nimport './x-button';\nimport './x-fakedata';\n\nclass XApp extends HyperHTMLElement {\n\n  static get observedAttributes() { return ['number']; }\n\n  created() {\n    this.number = Math.random() * 100;\n  }\n\n  attributeChangedCallback(name, prev, curr) {\n    this.render();\n  }\n\n  random(value = 100){\n    this.number = Math.random() * value;\n  }\n\n  render(){\n    return this.html`<section>\n      <p>Test with some random number: <strong>${this.number}</strong></p>\n      <x-button>Click me!</x-button>\n      <fake-data></fake-data>\n    </section>`;\n  }\n\n}\n\nXApp.define('x-app');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/x-app.js\n// module id = 12\n// module chunks = 0","var hyperHTML = (function (globalDocument) {'use strict';\n\n  /*! (c) 2017 Andrea Giammarchi @WebReflection, (MIT) */\n\n  // ---------------------------------------------\n  // hyperHTML Public API\n  // ---------------------------------------------\n\n  // The document must be swap-able at runtime.\n  // Needed by both basicHTML and nativeHTML\n  hyperHTML.document = globalDocument;\n\n  // hyperHTML.bind(el) ⚡️\n  function hyperHTML(template) {\n    var hyper = hypers.get(this);\n    if (\n      !hyper ||\n      hyper.template !== (FF ? unique(template) : template)\n    ) {\n      hyper = upgrade.apply(this, arguments);\n      hypers.set(this, hyper);\n    }\n    update.apply(hyper.updates, arguments);\n    return this;\n  }\n\n  // hyperHTML.adopt(el) 🐣\n  hyperHTML.adopt = function adopt(node) {\n    return function () {\n      notAdopting = false;\n      hyperHTML.apply(node, arguments);\n      notAdopting = true;\n      return node;\n    };\n  };\n\n  // hyperHTML.escape('<html>') => '&lt;text&gt;'\n  hyperHTML.escape = function escape(html) {\n    return html.replace(reEscape, fnEscape);\n  };\n\n  // hyperHTML.wire(obj, 'type:ID') ➰\n  hyperHTML.wire = function wire(obj, type) {\n    return arguments.length < 1 ?\n      wireContent('html') :\n      (obj == null ?\n        wireContent(type || 'html') :\n        wireWeakly(obj, type || 'html')\n      );\n  };\n\n  // - - - - - - - - - - - - - - - - - - - - - - -\n\n  // ---------------------------------------------\n  // Constants\n  // ---------------------------------------------\n\n  // Node.CONSTANTS\n  // without assuming Node is globally available\n  // since this project is used on the backend too\n  var ELEMENT_NODE = 1;\n  var ATTRIBUTE_NODE = 2;\n  var TEXT_NODE = 3;\n  var COMMENT_NODE = 8;\n  var DOCUMENT_FRAGMENT_NODE = 11;\n\n  // SVG related\n  var OWNER_SVG_ELEMENT = 'ownerSVGElement';\n  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\n  var SHOULD_USE_ATTRIBUTE = /^style$/i;\n  var EXPANDO = '_hyper_html: ';\n  var UID = EXPANDO + ((Math.random() * new Date) | 0) + ';';\n  var UIDC = '<!--' + UID + '-->';\n\n  // ---------------------------------------------\n  // DOM Manipulation\n  // ---------------------------------------------\n\n  // return -1 if no differences are found\n  // the index where differences starts otherwise\n  function indexOfDifferences(a, b) {\n    var\n      i = 0,\n      aLength = a.length,\n      bLength = b.length\n    ;\n    while (i < aLength) {\n      if (i < bLength && a[i] === b[i]) i++;\n      else return i;\n    }\n    return i === bLength ? -1 : i;\n  }\n\n  // accordingly with the content type\n  // it replace the content of a node\n  // with the give child\n  function populateNode(parent, child) {\n    switch (child.nodeType) {\n      case ELEMENT_NODE:\n        var childNodes = parent.childNodes;\n        if (childNodes[0] === child) {\n          removeNodeList(childNodes, 1);\n          break;\n        }\n        resetAndPopulate(parent, child);\n        break;\n      case DOCUMENT_FRAGMENT_NODE:\n        if (indexOfDifferences(parent.childNodes, child.childNodes) !== -1) {\n          resetAndPopulate(parent, child);\n        }\n        break;\n      case TEXT_NODE:\n        parent.textContent = child.textContent;\n        break;\n    }\n  }\n\n  // remove a list of nodes from startIndex to list.length\n  function removeNodeList(list, startIndex) {\n    var length = list.length, child;\n    while (startIndex < length--) {\n      child = list[length];\n      child.parentNode.removeChild(child);\n    }\n  }\n\n  // erase a node content and populate it\n  function resetAndPopulate(parent, child) {\n    parent.textContent = '';\n    parent.appendChild(child);\n  }\n\n  // append childNodes to a node from a specific index\n  function updateViaArray(node, childNodes, i) {\n    var fragment = emptyFragment(node);\n    if (i !== 0) {\n      removeNodeList(node.childNodes, i);\n      appendNodes(fragment, childNodes.slice(i));\n      node.appendChild(fragment);\n    } else {\n      appendNodes(fragment, childNodes);\n      resetAndPopulate(node, fragment);\n    }\n  }\n\n  // ---------------------------------------------\n  // hyperHTML Operations\n  // ---------------------------------------------\n\n  // `<div>${'any'}</div>`\n  function setAnyContent(node) {\n    return function any(value) {\n      switch (typeof value) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          node.innerHTML = value;\n          break;\n        case 'function':\n          any(value(node, node.children, 0));\n          break;\n        default:\n          if (isArray(value)) {\n            var i, length = value.length;\n            if (length === 1) {\n              any(value[0]);\n            } else {\n              switch (length === 0 ? '' : typeof value[0]) {\n                case 'string':\n                case 'number':\n                case 'boolean':\n                  any(value.join(''));\n                  break;\n                case 'function':\n                  var children = slice.call(node.children);\n                  for (i = 0, length = value.length; i < length; i++) {\n                    value[i] = value[i](node, children, i);\n                  }\n                  removeNodeList(children, i);\n                  any(value.concat.apply([], value));\n                  break;\n                case 'object':\n                  if (isArray(value[0])) {\n                    value = value.concat.apply([], value);\n                  }\n                  if (isPromise_ish(value[0])) {\n                    Promise.all(value).then(any);\n                    break;\n                  }\n                default:\n                  i = indexOfDifferences(node.childNodes, value);\n                  if (i !== -1) updateViaArray(node, value, i);\n                  break;\n              }\n            }\n          } else if (isPromise_ish(value)) {\n            value.then(any);\n          } else {\n            populateNode(node, value);\n          }\n          break;\n      }\n    };\n  }\n\n  // `<div class=\"${'attr'}\"></div>`\n  // `<div onclick=\"${function () {... }}\"></div>`\n  // `<div onclick=\"${{handleEvent(){ ... }}}\"></div>`\n  // `<div contenteditable=\"${true}\"></div>`\n  function setAttribute(attribute, removeAttributes) {\n    var\n      name = attribute.name,\n      node = attribute.ownerElement,\n      isEvent = /^on/.test(name),\n      isSpecial = name in node && !(\n                    // always use set attribute with SVGs\n                    OWNER_SVG_ELEMENT in node ||\n                    SHOULD_USE_ATTRIBUTE.test(name)\n                  ),\n      type = isEvent ? name.slice(2) : '',\n      oldValue\n    ;\n    if (isSpecial || isEvent) removeAttributes.push(node, name);\n    return isEvent ?\n      function eventAttr(newValue) {\n        if (oldValue !== newValue) {\n          if (oldValue) node.removeEventListener(type, oldValue, false);\n          oldValue = newValue;\n          if (newValue) node.addEventListener(type, newValue, false);\n        }\n      } :\n      (isSpecial ?\n        function specialAttr(newValue) {\n          if (oldValue !== newValue) {\n            oldValue = newValue;\n            // WebKit moves the cursor if input.value\n            // is set again, even if same value\n            if (node[name] !== newValue) {\n              node[name] = newValue;\n            }\n          }\n        } :\n        function normalAttr(newValue) {\n          if (oldValue !== newValue) {\n            oldValue = newValue;\n            // WebKit moves the cursor if input.value\n            // is set again, even if same value\n            if (attribute.value !== newValue) {\n              attribute.value = newValue;\n            }\n          }\n        }\n      );\n  }\n\n  // `<div> ${'text'} </div>`\n  function setTextContent(node) {\n    var oldValue;\n    return function text(newValue) {\n      if (oldValue !== newValue) {\n        oldValue = newValue;\n        node.textContent = newValue;\n      }\n    };\n  }\n\n  // `<li>a</li>${'virtual'}<li>c</li>`\n  function setVirtualContent(node, childNodes) {\n    return function anyVirtual(value) {\n      switch (typeof value) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          removeNodeList(childNodes, 0);\n          var fragment = createFragment(node, value);\n          childNodes = slice.call(fragment.childNodes);\n          node.parentNode.insertBefore(fragment, node);\n          break;\n        case 'function':\n          anyVirtual(value(node.parentNode, childNodes, 0));\n          break;\n        default:\n          if (isArray(value)) {\n            if (value.length === 0) {\n              removeNodeList(childNodes, 0);\n              childNodes = [];\n            } else {\n              switch (typeof value[0]) {\n                case 'string':\n                case 'number':\n                case 'boolean':\n                  anyVirtual(value.join(''));\n                  break;\n                case 'function':\n                  var parentNode = node.parentNode;\n                  for (var i = 0, length = value.length; i < length; i++) {\n                    value[i] = value[i](parentNode, childNodes, i);\n                  }\n                  anyVirtual(value.concat.apply([], value));\n                  break;\n                case 'object':\n                  if (isArray(value[0])) {\n                    value = value.concat.apply([], value);\n                  }\n                  if (isPromise_ish(value[0])) {\n                    Promise.all(value).then(anyVirtual);\n                    break;\n                  }\n                default:\n                  updateVirtualNodes(node, childNodes, value);\n                  break;\n              }\n            }\n          } else if (isPromise_ish(value)) {\n            value.then(anyVirtual);\n          } else {\n            updateVirtualNodes(\n              node,\n              childNodes,\n              value.nodeType === DOCUMENT_FRAGMENT_NODE ?\n                slice.call(value.childNodes) :\n                [value]\n            );\n          }\n          break;\n      }\n    };\n  }\n\n  // ---------------------------------------------\n  // DOM Traversing\n  // ---------------------------------------------\n\n  // look for attributes that contains the comment text\n  function attributesSeeker(node, paths) {\n    for (var\n      attribute,\n      value = IE ? UID : UIDC,\n      attributes = node.attributes,\n      i = 0, length = attributes.length;\n      i < length; i++\n    ) {\n      attribute = attributes[i];\n      if (attribute.value === value) {\n        paths.push(\n          Path(\n            'attr',\n            // with IE the order doesn't really matter\n            // as long as the right attribute is addressed\n            IE ?\n              node.attributes[IEAttributes.shift()] :\n              attribute\n          )\n        );\n      }\n    }\n  }\n\n  // walk the fragment tree in search of comments\n  function commentsSeeker(node, paths) {\n    for (var\n      child, text,\n      childNodes = node.childNodes,\n      length = childNodes.length,\n      i = 0; i < length; i++\n    ) {\n      child = childNodes[i];\n      switch (child.nodeType) {\n        case ELEMENT_NODE:\n          attributesSeeker(child, paths);\n          commentsSeeker(child, paths);\n          break;\n        case COMMENT_NODE:\n          if (child.textContent === UID) {\n            if (length === 1) {\n              paths.push(Path('any', node));\n            } else if (\n              (i < 1 || childNodes[i - 1].nodeType === ELEMENT_NODE) &&\n              (i + 1 === length || childNodes[i + 1].nodeType === ELEMENT_NODE)\n            ) {\n              paths.push(Path('virtual', child));\n            } else {\n              text = createText(child, '');\n              child.parentNode.replaceChild(text, child);\n              paths.push(Path('text', text));\n            }\n          }\n          break;\n        case TEXT_NODE:\n          if (SHOULD_USE_ATTRIBUTE.test(node.nodeName) && child.textContent === UIDC) {\n            paths.push(Path('text', node));\n          }\n          break;\n      }\n    }\n  }\n\n  // ---------------------------------------------\n  // Features detection / ugly UA sniffs\n  // ---------------------------------------------\n  var featureFragment = createDocumentFragment(globalDocument);\n\n  // Firefox < 55 has non standard template literals.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1108941\n  // TODO: is there any better way to feature detect this ?\n  var FF = typeof navigator === 'object' &&\n            /Firefox\\/(\\d+)/.test(navigator.userAgent) &&\n            parseFloat(RegExp.$1) < 55;\n\n  // If attributes order is shuffled, threat the browser differently\n  // Usually this is a well known IE only limitation but some older FF does the same.\n  var IE =  (function () {\n              var p  = globalDocument.createElement('p');\n              p.innerHTML = '<i data-i=\"\" class=\"\"></i>';\n              return /class/i.test(p.firstChild.attributes[0].name);\n            }());\n\n\n  // beside IE, old WebKit browsers don't have `children` in DocumentFragment\n  var WK = !('children' in featureFragment);\n\n  // ---------------------------------------------\n  // Helpers\n  // ---------------------------------------------\n\n  // used to convert childNodes to Array\n  var slice = [].slice;\n\n  // used to sanitize html\n  var reEscape = /[&<>'\"]/g;\n  var oEscape = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    \"'\": '&#39;',\n    '\"': '&quot;'\n  };\n  function fnEscape(m) {\n    return oEscape[m];\n  }\n\n  // return a single node or an Array or nodes\n  function createContent(node) {\n    for (var\n      child,\n      content = [],\n      childNodes = node.childNodes,\n      i = 0,\n      length = childNodes.length;\n      i < length; i++\n    ) {\n      child = childNodes[i];\n      if (\n        child.nodeType === ELEMENT_NODE ||\n        trim.call(child.textContent).length !== 0\n      ) {\n        content.push(child);\n      }\n    }\n    return content.length === 1 ? content[0] : content;\n  }\n\n  // just a minifier friendly indirection\n  function createDocumentFragment(document) {\n    return document.createDocumentFragment();\n  }\n\n  // given a node, inject some html and return\n  // the resulting template document fragment\n  function createFragment(node, html) {\n    return (\n      OWNER_SVG_ELEMENT in node ?\n        createSVGFragment :\n        createHTMLFragment\n    )(node, html);\n  }\n\n  // create fragment for HTML\n  function createHTMLFragment(node, html) {\n    var fragment;\n    var document = node.ownerDocument;\n    var container = document.createElement('template');\n    var hasContent = 'content' in container;\n    var needsTableWrap = false;\n    if (!hasContent) {\n      // DO NOT MOVE THE FOLLOWING LINE ELSEWHERE\n      fragment = createDocumentFragment(document);\n      // (a jsdom + nodejs tests coverage gotcha)\n\n      // el.innerHTML = '<td></td>'; is not possible\n      // if the content is a partial internal table content\n      // it needs to be wrapped around once injected.\n      // HTMLTemplateElement does not suffer this issue.\n      needsTableWrap = /^[^\\S]*?<(t(?:head|body|foot|r|d|h))/i.test(html);\n    }\n    if (needsTableWrap) {\n      // secure the RegExp.$1 result ASAP to avoid issues\n      // in case a non-browser DOM library uses RegExp internally\n      // when HTML content is injected (basicHTML / jsdom / others...)\n      var selector = RegExp.$1;\n      container.innerHTML = '<table>' + html + '</table>';\n      appendNodes(fragment, slice.call(container.querySelectorAll(selector)));\n    } else {\n      container.innerHTML = html;\n      if (hasContent) {\n        fragment = container.content;\n      } else {\n        appendNodes(fragment, slice.call(container.childNodes));\n      }\n    }\n    return fragment;\n  }\n\n  // create a fragment for SVG\n  function createSVGFragment(node, html) {\n    var document = node.ownerDocument;\n    var fragment = createDocumentFragment(document);\n    var container = document.createElementNS(SVG_NAMESPACE, 'svg');\n    container.innerHTML = html;\n    appendNodes(fragment, slice.call(container.childNodes));\n    return fragment;\n  }\n\n  // given a node, it does what is says\n  function createText(node, text) {\n    return node.ownerDocument.createTextNode(text);\n  }\n\n  // given an info, tries to find out the best option\n  // to replace or update the content\n  function discoverNode(parentNode, virtual, info, childNodes) {\n    for (var\n      target = parentNode,\n      document = parentNode.ownerDocument,\n      path = info.path,\n      virtualNode = getNode(virtual, path),\n      i = 0,\n      length = path.length;\n      i < length; i++\n    ) {\n      switch (path[i++]) {\n        case 'attributes':\n          var name = virtualNode.name;\n          if (!parentNode.hasAttribute(name)) {\n            parentNode.setAttribute(name, '');\n          }\n          target = parentNode.attributes[name];\n          break;\n        case 'childNodes':\n          switch (info.type) {\n            // TODO: supports multiple text per element ?\n            case 'text':\n              var before = getTextContent(virtualNode, 'previous');\n              var after = getTextContent(virtualNode, 'next');\n              do {\n                target = parentNode.firstChild;\n                if (target && target.nodeType === TEXT_NODE) {\n                  parentNode.removeChild(target);\n                } else {\n                  break;\n                }\n              } while (target);\n              var fragment = createDocumentFragment(document);\n              if (before.length) {\n                fragment.appendChild(createText(parentNode, before));\n              }\n              target = fragment.appendChild(createText(parentNode, ''));\n              if (after.length) {\n                fragment.appendChild(createText(parentNode, after));\n              }\n              parentNode.insertBefore(fragment, parentNode.firstChild);\n              break;\n            // TODO: supports multiple virtual content per element ?\n            case 'virtual':\n              var children = getChildren(parentNode);\n              var virtualChildren = getChildren(virtualNode.parentNode);\n              target = previousElementSibling(virtualNode);\n              var before = target ? (path.indexOf.call(virtualChildren, target) + 1) : -1;\n              target = nextElementSibling(virtualNode);\n              var after = target ? path.indexOf.call(virtualChildren, target) : -1;\n              target = document.createComment(UID);\n              switch (true) {\n                // `${'virtual'}` is actually resolved as `${'any'}`\n                // case before < 0 && after < 0: before = 0;\n\n                // `</a>${'virtual'}`\n                case after < 0:\n                  after = children.length;\n                  break;\n                // `${'virtual'}<b>`\n                case before < 0:\n                  before = 0;\n                // `</a>${'virtual'}<b>`\n                default:\n                  after = -(virtualChildren.length - after);\n                  break;\n              }\n              childNodes.push.apply(\n                childNodes,\n                slice.call(children, before, after)\n              );\n              parentNode.insertBefore(\n                target,\n                childNodes.length ?\n                  nextElementSibling(childNodes[childNodes.length - 1]) :\n                  slice.call(children, after)[0]\n              );\n              if (childNodes.length === 0) {\n                removePreviousText(parentNode, target);\n              }\n              break;\n          }\n          break;\n        default:\n          // if the node is not there, create it\n          target = getChildren(parentNode)[path[i]] ||\n                    parentNode.appendChild(\n                      parentNode.ownerDocument.createElement(\n                        getNode(virtual, path.slice(0, i + 1)).nodeName\n                      )\n                    );\n          parentNode = target;\n          break;\n      }\n    }\n    return target;\n  }\n\n  // create an empty fragment from a generic node\n  function emptyFragment(node) {\n    return createDocumentFragment(node.ownerDocument);\n  }\n\n  // given a node, returns text content before it or after it\n  function getTextContent(node, direction) {\n    var content = [];\n    var method = direction === 'next' ?\n        content.push : content.unshift;\n    do {\n      node = node[direction + 'Sibling'];\n      if (node && node.nodeType === TEXT_NODE) {\n        method.call(content, node.textContent);\n      } else {\n        return content.join('');\n      }\n    } while (true);\n  }\n\n  // quick and dirty Promise check\n  function isPromise_ish(value) {\n    return value != null && 'then' in value;\n  }\n\n  // remove a list of [node, attribute]\n  function removeAttributeList(list) {\n    for (var i = 0, length = list.length; i < length; i++) {\n      list[i++].removeAttribute(list[i]);\n    }\n  }\n\n  // remove all text nodes from a virtual space\n  function removePreviousText(parentNode, node) {\n    var previousSibling = node.previousSibling;\n    if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n      parentNode.removeChild(previousSibling);\n      removePreviousText(parentNode, node);\n    }\n  }\n\n  // specify the content to update\n  function setContent(type, target, removeAttributes, childNodes) {\n    var update;\n    switch (type) {\n      case 'any':\n        update = setAnyContent(target);\n        break;\n      case 'attr':\n        update = setAttribute(target, removeAttributes);\n        break;\n      case 'text':\n        update = setTextContent(target);\n        break;\n      case 'virtual':\n        update = setVirtualContent(target, childNodes);\n        break;\n    }\n    return update;\n  }\n\n  // update partially or fully the list of virtual nodes\n  // it modifies in place the childNodes list if necessary\n  function updateVirtualNodes(node, childNodes, value) {\n    var i = indexOfDifferences(childNodes, value);\n    if (i !== -1) {\n      var fragment = emptyFragment(node);\n      removeNodeList(childNodes, i);\n      childNodes.splice(i);\n      value = value.slice(i);\n      appendNodes(fragment, value);\n      node.parentNode.insertBefore(fragment, node);\n      childNodes.push.apply(childNodes, value);\n    }\n  }\n\n  // used for common path creation.\n  function Path(type, node) {\n    return {type: type, path: createPath(node)};\n  }\n\n  // ---------------------------------------------\n  // Hybrid Shims\n  // ---------------------------------------------\n\n  // WeakMap with partial EXPANDO fallback\n  var $WeakMap = typeof WeakMap === typeof $WeakMap ?\n      function () {\n        return {\n          get: function (obj) { return obj[EXPANDO]; },\n          set: function (obj, value) {\n            Object.defineProperty(obj, EXPANDO, {\n              configurable: true,\n              value: value\n            });\n          }\n        };\n      } :\n      WeakMap;\n\n  // Map with partial double Array fallback\n  var $Map = typeof Map === typeof $Map ?\n      function () {\n        var k = [], v = [];\n        return {\n          get: function (obj) {\n            return v[k.indexOf(obj)];\n          },\n          // being used with unique template literals\n          // there is never a case when a value is overwritten\n          // no need to check upfront for the indexOf\n          set: function (obj, value) {\n            v[k.push(obj) - 1] = value;\n          }\n        };\n      } :\n      Map;\n\n  // TODO: which browser needs these partial polyfills here?\n\n  // BB7 and webOS need this\n  var isArray = Array.isArray ||\n                (function () {\n                  var toString = {}.toString;\n                  // I once had an engine returning [array Array]\n                  // and I've got scared since!\n                  var s = toString.call([]);\n                  return function (a) {\n                    return toString.call(a) === s;\n                  };\n                }());\n\n  // older WebKit need this\n  var trim = EXPANDO.trim ||\n              function () { return this.replace(/^\\s+|\\s+$/g, ''); };\n\n  // ---------------------------------------------\n  // Shared variables\n  // ---------------------------------------------\n\n  // normalize Firefox issue with template literals\n  var templateObjects, unique;\n  if (FF) {\n    templateObjects = Object.create(null);\n    unique = function (template) {\n      var key = template.join(UID);\n      return templateObjects[key] ||\n            (templateObjects[key] = template);\n    };\n  }\n\n  // use native .append(...childNodes) where available\n  var appendNodes = 'append' in featureFragment ?\n      function (node, childNodes) {\n        node.append.apply(node, childNodes);\n      } :\n      function appendNodes(node, childNodes) {\n        for (var\n          i = 0,\n          length = childNodes.length;\n          i < length; i++\n        ) {\n          node.appendChild(childNodes[i]);\n        }\n      };\n\n  // traps function bind once (useful in destructuring)\n  var bind = hyperHTML.bind;\n  hyperHTML.bind = function () { return bind.apply(hyperHTML, arguments); };\n\n  // returns children or retrieve them in IE/Edge\n  var getChildren = WK ?\n      function (node) {\n        for (var\n          child,\n          children = [],\n          childNodes = node.childNodes,\n          j = 0, i = 0, length = childNodes.length;\n          i < length; i++\n        ) {\n          child = childNodes[i];\n          if (child.nodeType === ELEMENT_NODE)\n            children[j++] = child;\n        }\n        return children;\n      } :\n      function (node) { return node.children; };\n\n  // return the correct node walking through a path\n  // fixes IE/Edge issues with attributes and children (fixes old WebKit too)\n  var getNode = IE || WK ?\n      function (parentNode, path) {\n        for (var name, i = 0, length = path.length; i < length; i++) {\n          name = path[i++];\n          switch (name) {\n            case 'children':\n              parentNode = getChildren(parentNode)[path[i]];\n              break;\n            default:\n              parentNode = parentNode[name][path[i]];\n              break;\n          }\n        }\n        return parentNode;\n      } :\n      function (parentNode, path) {\n        for (var i = 0, length = path.length; i < length; i++) {\n          parentNode = parentNode[path[i++]][path[i]];\n        }\n        return parentNode;\n      };\n\n  // fixes IE problems with comments\n  if (IE) {\n    var IEAttributes;\n    var no = new RegExp('([^\\\\S][a-z]+[a-z0-9_-]*=)([\\'\"])' + UIDC + '\\\\2', 'g');\n    var comments = function ($0, $1, $2) {\n          IEAttributes.push($1.slice(1, -1));\n          return $1 + $2 + UID + $2;\n        };\n  }\n\n  // IE/Edge gotcha with comment nodes\n  var nextElementSibling = IE ?\n    function (node) {\n      node = node.nextSibling;\n      return node && node.nodeType === ELEMENT_NODE ? node : undefined;\n    } :\n    function (node) { return node.nextElementSibling; };\n\n  var previousElementSibling = IE ?\n    function (node) {\n      node = node.previousSibling;\n      return node && node.nodeType === ELEMENT_NODE ? node : undefined;\n    } :\n    function (node) { return node.previousElementSibling; };\n\n  // [element] = {template, updates};\n  var hypers = new $WeakMap;\n\n  // [element] = {template, updates};\n  var wires = new $WeakMap;\n\n  // [template] = {fragment, paths};\n  var templates = new $Map;\n\n  // internal signal to switch adoption\n  var notAdopting = true;\n\n  // IE 11 has problems with cloning templates too\n  // it \"forgets\" empty childNodes\n  var cloneNode = (function () {\n    featureFragment.appendChild(createText(featureFragment, 'g'));\n    featureFragment.appendChild(createText(featureFragment, ''));\n    return featureFragment.cloneNode(true).childNodes.length === 1 ?\n      function (node) {\n        for (var\n          clone = node.cloneNode(),\n          childNodes = node.childNodes || [],\n          i = 0, length = childNodes.length;\n          i < length; i++\n        ) {\n          clone.appendChild(cloneNode(childNodes[i]));\n        }\n        return clone;\n      } :\n      function (fragment) {\n        return fragment.cloneNode(true);\n      };\n  }());\n\n  // ---------------------------------------------\n  // Template related utilities\n  // ---------------------------------------------\n\n  // given a unique template object\n  // create, parse, and store retrieved info\n  function createTemplate(template) {\n    var paths = [];\n    var html = template.join(UIDC);\n    if (IE) {\n      IEAttributes = [];\n      html = html.replace(no, comments);\n    }\n    var fragment = createFragment(this, html);\n    var info = {fragment: fragment, paths: paths};\n    commentsSeeker(fragment, paths);\n    templates.set(template, info);\n    return info;\n  }\n\n  // given a generic node, returns a path capable\n  // of retrieving such path back again.\n  // TODO: worth passing the index when available ?\n  function createPath(node) {\n    var path = [];\n    var parentNode;\n    switch(node.nodeType) {\n      case ELEMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        parentNode = node;\n        break;\n      case TEXT_NODE:\n      case COMMENT_NODE:\n        parentNode = node.parentNode;\n        path.unshift(\n          'childNodes',\n          path.indexOf.call(parentNode.childNodes, node)\n        );\n        break;\n      case ATTRIBUTE_NODE:\n      default: // jsdom here does not provide a nodeType 2 ...\n        parentNode = node.ownerElement;\n        path.unshift('attributes', node.name);\n        break;\n    }\n    for (\n      node = parentNode;\n      parentNode = parentNode.parentNode;\n      node = parentNode\n    ) {\n      path.unshift('children', path.indexOf.call(getChildren(parentNode), node));\n    }\n    return path;\n  }\n\n  // given a root node and a list of paths\n  // creates an array of updates to invoke\n  // whenever the next interpolation happens\n  function createUpdates(fragment, paths) {\n    for (var\n      info, target,\n      updates = [],\n      removeAttributes = [],\n      i = 0, length = paths.length;\n      i < length; i++\n    ) {\n      info = paths[i];\n      target = getNode(fragment, info.path);\n      if (target.nodeType === DOCUMENT_FRAGMENT_NODE) {\n        removeNodeList(target.childNodes, 0);\n        target = this;\n      }\n      updates[i] = setContent(info.type, target, removeAttributes, []);\n    }\n    removeAttributeList(removeAttributes);\n    return updates;\n  }\n\n  // like createUpdates but for nodes with already a content\n  function discoverUpdates(fragment, paths) {\n    for (var\n      info, childNodes,\n      updates = [],\n      removeAttributes = [],\n      i = 0, length = paths.length;\n      i < length; i++\n    ) {\n      childNodes = [];\n      info = paths[i];\n      updates[i] = setContent(\n        info.type,\n        discoverNode(this, fragment, info, childNodes),\n        removeAttributes,\n        childNodes\n      );\n    }\n    removeAttributeList(removeAttributes);\n    return updates;\n  }\n\n  // invokes each update function passing interpolated value\n  function update() {\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      this[i - 1](arguments[i]);\n    }\n  }\n\n  // create a template, if unknown\n  // upgrade a node to use such template for future updates\n  function upgrade(template) {\n    if (FF) template = unique(template);\n    var updates;\n    var info =  templates.get(template) ||\n                createTemplate.call(this, template);\n    if (notAdopting) {\n      var fragment = cloneNode(info.fragment);\n      updates = createUpdates.call(this, fragment, info.paths);\n      resetAndPopulate(this, fragment);\n    } else {\n      updates = discoverUpdates.call(this, info.fragment, info.paths);\n    }\n    return {template: template, updates: updates};\n  }\n\n  // ---------------------------------------------\n  // Wires\n  // ---------------------------------------------\n\n  // create a new wire for generic DOM content\n  function wireContent(type) {\n    var adopter, content, container, fragment, render, setup, template;\n\n    function before(document) {\n      fragment = createDocumentFragment(document);\n      container = type === 'svg' ?\n        document.createElementNS(SVG_NAMESPACE, 'svg') :\n        fragment;\n      render = hyperHTML.bind(container);\n    }\n\n    function after() {\n      if (setup) {\n        setup = false;\n        if (type === 'svg') {\n          appendNodes(fragment, slice.call(container.childNodes));\n        }\n        content = createContent(fragment);\n      }\n      return content;\n    }\n\n    return type === 'adopt' ?\n      function adopt(statics) {\n        var args = arguments;\n        if (FF) statics = unique(statics);\n        if (template !== statics) {\n          setup = true;\n          template = statics;\n          adopter = function (parentNode, children, i) {\n            if (setup) {\n              if (i < children.length) {\n                container = children[i];\n                fragment = {\n                  ownerDocument: container.ownerDocument,\n                  childNodes: [container],\n                  children: [container]\n                };\n                render = hyperHTML.adopt(fragment);\n              } else {\n                if (OWNER_SVG_ELEMENT in parentNode) type = 'svg';\n                before(parentNode.ownerDocument);\n              }\n            }\n            render.apply(null, args);\n            return after();\n          };\n        }\n        return adopter;\n      } :\n      function update(statics) {\n        if (FF) statics = unique(statics);\n        if (template !== statics) {\n          setup = true;\n          template = statics;\n          before(hyperHTML.document);\n        }\n        render.apply(null, arguments);\n        return after();\n      };\n  }\n\n  // setup a weak reference if needed and return a wire by ID\n  function wireWeakly(obj, type) {\n    var wire = wires.get(obj);\n    var i = type.indexOf(':');\n    var id = type;\n    if (-1 < i) {\n      id = type.slice(i + 1);\n      type = type.slice(0, i) || 'html';\n    }\n    if (!wire) {\n      wire = {};\n      wires.set(obj, wire);\n    }\n    return wire[id] || (wire[id] = wireContent(type));\n  }\n\n  // ---------------------------------------------\n  // ⚡️ ️️The End ➰\n  // ---------------------------------------------\n  return hyperHTML;\n\n}(document));\n\n// umd.KISS\ntry { module.exports = hyperHTML; } catch(o_O) {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/hyperhtml/hyperhtml.js\n// module id = 13\n// module chunks = 0","'use strict';\n\nimport HyperHTMLElement from 'hyperhtml-element';\nimport { Observable} from 'rxjs-es/Observable';\nimport 'rxjs-es/add/observable/fromEvent';\nimport 'rxjs-es/add/operator/map';\n\nclass XButton extends HyperHTMLElement {\n\n  created(){\n    this.attachShadow({mode: 'open'});\n    this.render();\n  }\n\n  render(){\n    return this.html`<button><slot></slot></button>`;\n  }\n\n\n  connectedCallback(){\n    Observable.fromEvent(this, 'click')\n      .map(evt => {\n        console.log(evt);\n        return { x: evt.clientX , y: evt.clientY }\n      })\n      .forEach(data => console.log(JSON.stringify(data)));\n  }\n\n}\n\nXButton.define('x-button');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/x-button.js\n// module id = 14\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 15\n// module chunks = 0","import { Subscriber } from '../Subscriber';\nimport { $$rxSubscriber } from '../symbol/rxSubscriber';\nexport function toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[$$rxSubscriber]) {\n            return nextOrObserver[$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber();\n    }\n    return new Subscriber(nextOrObserver, error, complete);\n}\n//# sourceMappingURL=toSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/toSubscriber.js\n// module id = 16\n// module chunks = 0","export const isArray = Array.isArray || ((x) => x && typeof x.length === 'number');\n//# sourceMappingURL=isArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/isArray.js\n// module id = 17\n// module chunks = 0","export function isObject(x) {\n    return x != null && typeof x === 'object';\n}\n//# sourceMappingURL=isObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/isObject.js\n// module id = 18\n// module chunks = 0","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n    constructor(errors) {\n        super();\n        this.errors = errors;\n        const err = Error.call(this, errors ?\n            `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n}\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/util/UnsubscriptionError.js\n// module id = 19\n// module chunks = 0","export const empty = {\n    closed: true,\n    next(value) { },\n    error(err) { throw err; },\n    complete() { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/Observer.js\n// module id = 20\n// module chunks = 0","import { root } from '../util/root';\nexport function getSymbolObservable(context) {\n    let $$observable;\n    let Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexport const $$observable = getSymbolObservable(root);\n//# sourceMappingURL=observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/symbol/observable.js\n// module id = 21\n// module chunks = 0","import { Observable } from '../../Observable';\nimport { fromEvent as staticFromEvent } from '../../observable/fromEvent';\nObservable.fromEvent = staticFromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/add/observable/fromEvent.js\n// module id = 22\n// module chunks = 0","import { FromEventObservable } from './FromEventObservable';\nexport const fromEvent = FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/observable/fromEvent.js\n// module id = 23\n// module chunks = 0","import { Observable } from '../Observable';\nimport { tryCatch } from '../util/tryCatch';\nimport { isFunction } from '../util/isFunction';\nimport { errorObject } from '../util/errorObject';\nimport { Subscription } from '../Subscription';\nfunction isNodeStyleEventEmmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromEventObservable extends Observable {\n    constructor(sourceObj, eventName, selector, options) {\n        super();\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * Creates an Observable by attaching an event listener to an \"event target\",\n     * which may be an object with `addEventListener` and `removeEventListener`,\n     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the\n     * DOM, or an HTMLCollection from the DOM. The event handler is attached when\n     * the output Observable is subscribed, and removed when the Subscription is\n     * unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * @see {@link from}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOMElement, event target, Node.js\n     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @parm {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    static create(target, eventName, options, selector) {\n        if (isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    }\n    static setupSubscription(sourceObj, eventName, handler, subscriber, options) {\n        let unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (let i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            const source = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = () => source.removeEventListener(eventName, handler);\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            const source = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = () => source.off(eventName, handler);\n        }\n        else if (isNodeStyleEventEmmitter(sourceObj)) {\n            const source = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = () => source.removeListener(eventName, handler);\n        }\n        subscriber.add(new Subscription(unsubscribe));\n    }\n    _subscribe(subscriber) {\n        const sourceObj = this.sourceObj;\n        const eventName = this.eventName;\n        const options = this.options;\n        const selector = this.selector;\n        let handler = selector ? (...args) => {\n            let result = tryCatch(selector)(...args);\n            if (result === errorObject) {\n                subscriber.error(errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : (e) => subscriber.next(e);\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    }\n}\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/observable/FromEventObservable.js\n// module id = 24\n// module chunks = 0","import { Subscriber } from '../Subscriber';\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexport class MapOperator {\n    constructor(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    call(subscriber, source) {\n        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber extends Subscriber {\n    constructor(destination, project, thisArg) {\n        super(destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    _next(value) {\n        let result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    }\n}\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/operator/map.js\n// module id = 25\n// module chunks = 0","'use strict';\n\nimport HyperHTMLElement from 'hyperhtml-element';\nimport { Observable} from 'rxjs-es/Observable';\nimport 'rxjs-es/add/observable/fromPromise';\nimport 'rxjs-es/add/operator/map';\n\nclass FakeData extends HyperHTMLElement {\n\n  static get observedAttributes() { return ['items']; }\n\n  created(){\n    this.attachShadow({mode: 'open'});\n    this.endpoint = 'https://jsonplaceholder.typicode.com/users';\n    this.items = [];\n\n    this.render();\n  }\n\n  attributeChangedCallback(name, prev, curr) {\n    console.log(name, prev, curr);\n    this.render();\n  }\n\n  printItems(items){\n    if(items !== ''){\n      const json = JSON.parse(items);\n      return json.map((e,i) => `<li>${e.name} | ${e.username}</li>` );\n    } else {\n      return '';\n    }\n  }\n\n  render(){\n    return this.html`<ul>${this.printItems(this.items)}</ul>`;\n  }\n\n\n  connectedCallback(){\n    const getData = fetch(this.endpoint).then(r => r.json());\n\n    Observable.fromPromise(getData)\n      .subscribe(data => {\n        console.log(data);\n        this.items = JSON.stringify(data);\n      });\n  }\n\n}\n\nFakeData.define('fake-data');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/x-fakedata.js\n// module id = 26\n// module chunks = 0","import { Observable } from '../../Observable';\nimport { fromPromise as staticFromPromise } from '../../observable/fromPromise';\nObservable.fromPromise = staticFromPromise;\n//# sourceMappingURL=fromPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/add/observable/fromPromise.js\n// module id = 27\n// module chunks = 0","import { PromiseObservable } from './PromiseObservable';\nexport const fromPromise = PromiseObservable.create;\n//# sourceMappingURL=fromPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/observable/fromPromise.js\n// module id = 28\n// module chunks = 0","import { root } from '../util/root';\nimport { Observable } from '../Observable';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PromiseObservable extends Observable {\n    constructor(promise, scheduler) {\n        super();\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {Promise<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    static create(promise, scheduler) {\n        return new PromiseObservable(promise, scheduler);\n    }\n    _subscribe(subscriber) {\n        const promise = this.promise;\n        const scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then((value) => {\n                    this.value = value;\n                    this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, (err) => {\n                    if (!subscriber.closed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, err => {\n                    // escape the promise trap, throw unhandled errors\n                    root.setTimeout(() => { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });\n                }\n            }\n            else {\n                promise.then((value) => {\n                    this.value = value;\n                    this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));\n                    }\n                }, (err) => {\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));\n                    }\n                })\n                    .then(null, (err) => {\n                    // escape the promise trap, throw unhandled errors\n                    root.setTimeout(() => { throw err; });\n                });\n            }\n        }\n    }\n}\nfunction dispatchNext(arg) {\n    const { value, subscriber } = arg;\n    if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(arg) {\n    const { err, subscriber } = arg;\n    if (!subscriber.closed) {\n        subscriber.error(err);\n    }\n}\n//# sourceMappingURL=PromiseObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs-es/observable/PromiseObservable.js\n// module id = 29\n// module chunks = 0"],"sourceRoot":""}